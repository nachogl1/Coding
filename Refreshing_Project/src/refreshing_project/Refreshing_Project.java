/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package refreshing_project;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 *
 * @author Ignacio_Gonzalez
 */
public class Refreshing_Project {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) { 
        //Binary Search Tree tests beginning
//        BinarySortedTree BST = new BinarySortedTree();
//        BST.addNode(30, "Pepe");
//        BST.addNode(33, "Maria");
//        BST.addNode(15, "Gon");
//        BST.addNode(35, "Nacho");
//        BST.addNode(32, "Nach2");
//        BST.addNode(20, "Carmen");
//        BST.addNode(18, "Jose");
//        BST.addNode(10, "Celia");
//        BST.addNode(10, "Celia2");
//        BST.inOrderTraversing(BST.root);
//        System.out.println("CHANGE TRAVERSING ALGORITHM");
//        BST.preOrderTraversing(BST.root);
//        System.out.println("CHANGE TRAVERSING ALGORITHM");
//        BST.postOrderTraversing(BST.root);
//        System.out.println("Search");
//        System.out.println(BST.findNode(180));
//        System.out.println("Eliminate number 1\nWas number 1 eliminated?: "+BST.remove(1));
//        System.out.println("Eliminate number 18\nWas number 18 eliminated?: "+BST.remove(18));
//         BST.inOrderTraversing(BST.root);
//        System.out.println("CHANGE TRAVERSING ALGORITHM");
//        BST.preOrderTraversing(BST.root);
//        System.out.println("CHANGE TRAVERSING ALGORITHM");
//        BST.postOrderTraversing(BST.root);
        //Binary Search Tree tests end

        //Graphs test beginning
//        Graph graph = new Graph();
//        graph.addVertex("Bob");
//        graph.addVertex("Alice");
//        graph.addVertex("Mark");
//        graph.addVertex("Rob");
//        graph.addVertex("Maria");
//        graph.addVertex("Pepe");
//        graph.addVertex("Mario");
//        graph.addEdge("Bob", "Alice");
//        graph.addEdge("Bob", "Rob");
//        graph.addEdge("Alice", "Mark");
//        graph.addEdge("Rob", "Mark");
//        graph.addEdge("Alice", "Maria");
//        graph.addEdge("Alice", "Pepe");
//        graph.addEdge("Rob", "Maria");
//        graph.addEdge("Rob", "Mario");
//        
//        System.out.println(graph.getAdjVertices());
//        graph.removeEdge("Bob", "Alice");
//        System.out.println(graph.getAdjVertices());
//        graph.remoVertex("Bob");
//        System.out.println(graph.getAdjVertices());
//        Map testMap = graph.getAdjVertices();
//        //Just to check the type of map we are using: HashMap
//        System.out.println(testMap.getClass().getName());
//        //DFT procedure
//        //It shows the path from Alice until it finishes, for example if you now add Bob without any edge, it will shows the same since Bob is not connected 
//        //to anyone
//        System.out.println(graph.depthFirstTraversal(graph, "Alice"));      
//        //BFT procedure
//        System.out.println(graph.breadthFirstTraversal(graph, "Alice"));
        //Graphs test end
    }

}
